#!/usr/bin/nesla
if (typeof(expect)!='function') include("_expect.ns");
function testcrypto() {
//	local key="hex:E76B2413958B00E193";
//	local key="hex:E76B2413958B00E1930000000000000000000000000000000000000000000000";
	local key="hex:40507649a9581e95d503367fe3c90fa1439122d5a55a2218c97b5994b71df243";

	if (typeof(crypto)!='table') {
		print("SKIPPING CRYPTO TESTS\n");
		return;
	}
	filename=_filepath+'/'+_filename;
	filestat=file.stat(filename);
	if (typeof(file.md5)!='function') {
		print("file.md5() missing\n");
	} else {
		expect("string.md5", "a9a47b7d0802b313924900ad1baa6eb0", string.md5("string.md5"));
		if (typeof(filestat)!='table') {
			print("test file ", filename, " does not exist.\n");
		} else {
			print(file.md5(filename), " *",filename,"\n");
			system("md5sum \""+filename+"\"");
		}
	}
	if (typeof(file.sha1)!='function') {
		print("file.sha1() missing\n");
	} else {
		expect("string.sha1", "2973a33e464d6b792720e9242e8b521eaf37e19a", string.sha1("string.sha1"));
		if (typeof(filestat)!='table') {
			print("test file ", filename, " does not exist.\n");
		} else {
			print(file.sha1(filename), " *",filename,"\n");
			system("sha1sum \""+filename+"\"");
		}
	}
	if (_ostype_=="DOS/turboc") return;
z	if (typeof(crypto.aes_ecb_encrypt)=='function') {
		x="crypto.aes_ecb_encrypt";
		x=base64.encode(crypto.aes_ecb_encrypt(x, key));
		x=crypto.aes_ecb_decrypt(base64.decode(x), key);
		expect("crypto.aes_ecb_encrypt", "crypto.aes_ecb_encrypt", x);
	}
	if (typeof(crypto.aes_cbc_encrypt)=='function') {
		/* an IV (Initialization Vector) is 16 bytes.
		 * that means a 32 byte string of hex.  no more and no less.
		 */
		iv='a9a47b7d0802b313924900ad1baa6eb0';

		x="crypto.aes_cbc_encrypt";
		x=base64.encode(crypto.aes_cbc_encrypt(x, key));
//		print(x,"\n");
		x=crypto.aes_cbc_decrypt(base64.decode(x), key);
		expect("crypto.aes_cbc_encrypt", "crypto.aes_cbc_encrypt", x);

		x="crypto.aes_cbc_encrypt"; // same as ^^^^^^
		x=base64.encode(crypto.aes_cbc_encrypt(x, key), 128, "");
//		print(x,"\n");
		x=crypto.aes_cbc_decrypt(base64.decode(x), key, 128, "");
		expect("crypto.aes_cbc_encrypt", "crypto.aes_cbc_encrypt", x);

		/* extra tests */
		x="crypto.aes_cbc_encrypt";
		x=base64.encode(crypto.aes_cbc_encrypt(x, key, 128, iv));
//		print(x,"\n");
		x=crypto.aes_cbc_decrypt(base64.decode(x), key, 128, iv);
		expect("crypto.aes_cbc_encrypt", "crypto.aes_cbc_encrypt", x);

		x="crypto.aes_cbc_encrypt";
		x=base64.encode(crypto.aes_cbc_encrypt(x, key, 192, iv));
//		print(x,"\n");
		x=crypto.aes_cbc_decrypt(base64.decode(x), key, 192, iv);
		expect("crypto.aes_cbc_encrypt", "crypto.aes_cbc_encrypt", x);

		x="crypto.aes_cbc_encrypt";
		x=base64.encode(crypto.aes_cbc_encrypt(x, key, 256, iv));
//		print(x,"\n");
		x=crypto.aes_cbc_decrypt(base64.decode(x), key, 256, iv);
		expect("crypto.aes_cbc_encrypt", "crypto.aes_cbc_encrypt", x);

	}
	if (typeof(crypto.aes_ecb_encrypt)!='function') {
		print("crypto.aes_ecb_encrypt() missing\n");
	} else {
		if (typeof(filestat)!='table') {
			print("test file ", filename, " does not exist.\n");
		} else {
			x=file.read(filename);
//			print("x=[",x,"]\n");
			print("x=[",mx=string.md5(x),"]\n");
			y=crypto.aes_ecb_encrypt(x, key);
			print("y=[",string.md5(y),"]\n");
			z=crypto.aes_ecb_decrypt(y, key);
			print("z=[",mz=string.md5(z),"]\n");
			expect(mx, mz, mx);
		}
	}
	if (typeof(crypto.aes_cbc_encrypt)!='function') {
		print("crypto.aes_cbc_encrypt() missing\n");
	} else {
		if (typeof(filestat)!='table') {
			print("test file ", filename, " does not exist.\n");
		} else {
			x=file.read(filename);
			print("x=[",mx=string.md5(x),"]\n");
			y=crypto.aes_cbc_encrypt(x, key);
			print("y=[",string.md5(y),"]\n");
			z=crypto.aes_cbc_decrypt(y, key);
			print("z=[",mz=string.md5(z),"]\n");
			expect(mx, mz, mx);
		}
	}
	return;
}
io.flush();
testcrypto();
global testcrypto=null;
io.flush();
