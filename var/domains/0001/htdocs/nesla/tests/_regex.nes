#!/usr/bin/nesla
if (typeof(expect)!='function') include("_expect.nes");
function testregex() {
	if (typeof(regex)!='table') {
		print("SKIPPING REGEX TESTS\n");
		return;
	}
#	print("REGEX TEST\n\n");
/*
	x=regex.match("\\((.*), (.*)\\)", "(a, b)");
	print("match x=",x,"\n");
	x=regex.match("\\((.*), (.*)\\)", "(a  b)");
	print("match x=",x,"\n");

//	\((.*), (.*)\)	(a, b)	y	(\2, \1)	(b, a)
	x=regex.replace("\\((.*), (.*)\\)", "(\\2, \\1)", "(a, b)");
	print("replace x=",x,"\n");

	x=regex.replace("(bc+d$|ef*g.|h?i(j|k))", "&-\\1-\\2", "reffgz");
	print("replace x=",x,"\n");

	x=regex.replace("(.*) is (.*)", "[&]\\1 was \\2", "This is a test.");
	print("replace x=",x,"\n");
*/
	p=file.read(_filepath+'/_regex.txt');
	if (typeof(p)!='string') { print("can't find _regex.txt\n"); return; }
	p=string.split(p, '\n');
	for (i=0;p[i]!=null;i++) {
		if (i<100) continue;
		if (i==95) continue; // test 95 seems broken
		if (sizeof(p[i])==0) break;
		r=string.split(p[i], '\t');
		if (r[2]=='c') {
			continue;
		} else if (r[2]=='n') {
			x=regex.match(r[0], r[1]);
			if (r[4]=='-') want=0; else want=r[4];
			expect("regex.match   "+tostring(i), want,       x);
		} else if (r[2]=='y') {
			x=regex.replace(r[0], r[3], r[1]);
			expect("regex.replace "+tostring(i), r[4],       x);
		} else {
			print("burp\n");
		}
	}
	p=null;
	return;
}
testregex();
p=null;
