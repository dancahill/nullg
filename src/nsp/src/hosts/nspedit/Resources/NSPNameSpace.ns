// output nsp namespace to an xml file

namespace nsp {
	class ns2xml{
		namespacename="NSPNameSpace";
		inputfilename="";
		outputfilename="";
		namespacedescriptions = {};
		output="";

		function ns2xml() {
			//printf("init\r\n");
			// load libraries to fill namespace
			if (_ostype_=="Windows/msvc" && _debug) dl.path = { @"N:\work\nsp\lib\shared" };
			dl.load("base");
			dl.load("net");
			foreach (d in dl.path) {
				printf("lib dir=%s\r\n", d);
/*
				foreach (n,v in base.dirlist(d)) {
					if (n.istr(".dll")!=null) {
						printf(" lib=%s\r\n", n);
					}
				}
*/
			}
			// done loading libs
			this.inputfilename=this.namespacename+".dat.ns";
			this.outputfilename=this.namespacename+".xml";
			this.namespacedescriptions = eval(file.readall(this.inputfilename));
			this.output="";
		};

		function begin() {
			this.out("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<!-- this file is auto-generated by "+this.namespacename+".ns -->\r\n<"+this.namespacename+">\r\n");
		};

		function end() {
			this.out("</"+this.namespacename+">\r\n");
		};

		function writefiles() {
			if (file.exists(this.outputfilename)) {
				printf("file %s already exists - renaming\r\n", this.outputfilename);
				file.unlink(this.outputfilename+".old");
				file.rename(this.outputfilename, this.outputfilename+".old");
			}
			file.writeall(this.outputfilename, this.output);
			//file.writeall("temp.ns", serialize(this.namespacedescriptions));
			//printf("serialize(this.namespacedescriptions) = %s", serialize(this.namespacedescriptions));
			//printf("this.output = %s", this.output);
			printf("file %s saved\r\n", this.outputfilename);
		};

		function out(s) {
			this.output+=s.tostring();
		};

		function printdepth(table, depth, pname) {
			padding="\t"*depth;
			foreach (n,v in table) {
				if (depth==1) {
					if (n=="decomped_script" || n=="nsp") continue;
				}
				t=v.gettype();
				d="";
				p=null;
				r=null;
				ns=pname+(pname==""?"":".")+n;
				if (t=="function") {
					d=sprintf("%s()", ns);
				} else if (t=="table") {
					d=sprintf("%s {}", ns);
				} else {
					d=sprintf("%s", ns);
				}
				namefound=false;
				foreach (name,entry in this.namespacedescriptions) {
					if (name==ns) {
						entry.type=t;
						d=entry.desc;
						if (entry.params!=null || entry.returns!=null) {
							if (entry.params!=null) p=entry.params;
							if (entry.returns!=null) r=entry.returns;
						}
						namefound=true;
						break;
					}
				}
				if (namefound==false && ns.sub(0, 5)!="_ENV.") {
					//printf("\t\t{ name=\"%s\", desc=\"\"; };\r\n", ns);
					printf("\t%s is undefined.\r\n", ns);
				} else if (d=="") {
					printf("\tdesc for %s is still blank.\r\n", ns);
				}
				if (t=="function") {
					if (p==null || r==null) {
						printf("\t%s is missing param or return data.\r\n", ns);
					}
				}
				if (t=="table") {
					if ((depth==1 && n=="_GLOBALS") || v.length()==0) {
						this.out(sprintf("%s<%s type=\"%s\" desc=\"%s\" />\r\n", padding, n, t, d));
					} else if (depth==1 && (n=="_ARGS" || n=="_ENV")) {
						this.out(sprintf("%s<%s type=\"%s\" desc=\"%s\" />\r\n", padding, n, t, d));
					} else {
						this.out(sprintf("%s<%s type=\"%s\" desc=\"%s\">\r\n", padding, n, t, d));
						this.printdepth(v, depth+1, ns);
						this.out(sprintf("%s</%s>\r\n", padding, n));
					}
				} else if (t=="function") {
					this.out(sprintf("%s<%s type=\"%s\" desc=\"%s\" params=\"%s\" returns=\"%s\" />\r\n", padding, n, t, d, p, r));
				} else {
					if (n.istr("(X86)")!=null || n=="0") continue;
					if (depth==1 && n=="null") t="null";
					this.out(sprintf("%s<%s type=\"%s\" desc=\"%s\" />\r\n", padding, n, t, d));
				}
			}
		}
	}
}

x=new nsp.ns2xml();
x.begin();
x.printdepth({true=true, false=false, this={}, null=false}, 1, "");
x.printdepth(_GLOBALS, 1, "");
x.end();
x.writefiles();
